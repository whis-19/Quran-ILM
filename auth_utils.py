import hashlib
import os
import random
import string
import secrets
import hashlib
import os
import random
import string
import secrets
import smtplib
import re
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import streamlit as st
from admin_utils import init_connection
import config

# Connect to DB
client, db, fs = init_connection()
users_collection = db["users"]

# --- Security Helpers ---

def hash_password(password):
    """Hashes password using SHA256 with a fixed salt (simple implementation)."""
    # In production, use bcrypt/argon2 and per-user salt.
    salt = "quran_ilm_secure_salt_v1"
    return hashlib.sha256((password + salt).encode()).hexdigest()

def verify_password(plain_password, hashed_password):
    return hash_password(plain_password) == hashed_password

def validate_password_strength(password):
    """
    Enforces password complexity:
    - Min 8 chars
    - At least 1 Uppercase
    - At least 1 Lowercase
    - At least 1 Number
    - At least 1 Special Char
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long."
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter."
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter."
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number."
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character."
    
    return True, "Valid"

def generate_otp():
    """Generates a 6-digit OTP."""
    return ''.join(random.choices(string.digits, k=6))

def send_email(to_email, subject, body):
    """Sends email via SMTP if configured, else mocks it."""
    
    smtp_server = config.SMTP_SERVER
    smtp_port = config.SMTP_PORT
    smtp_user = config.SMTP_EMAIL
    smtp_pass = config.SMTP_PASSWORD

    # --- DISCLAIMER ---
    disclaimer = """
----------------------------
IMPORTANT DISCLAIMER:
This content is generated by an Artificial Intelligence (AI) model and is for educational and informational research purposes ONLY.
It DOES NOT constitute a valid Islamic Fatwa (Religious Ruling) or a substitute for scholarly religious advice.
For specific religious inquiries or rulings, please consult a qualified scholar to avoid religious conflicts or misunderstandings.
The developers and maintainers of this system bear no responsibility for any misuse or misinterpretation of the provided information.
----------------------------
"""
    full_body = body + "\n" + disclaimer
    
    # Check if configured
    if not smtp_user or not smtp_pass or "your_app_password" in smtp_pass:
        print(f"\n[EMAIL MOCK] To: {to_email} | Subject: {subject}\nBody: {full_body}\n")
        return True

    try:
        msg = MIMEText(full_body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = to_email

        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            
        print(f"[EMAIL SUCCESS] Sent to {to_email}")
        return True
    except Exception as e:
        print(f"[EMAIL ERROR] Failed to send: {e}")
        # Fallback to mock so user isn't stuck
        print(f"[EMAIL MOCK FALLBACK] Code for {to_email} is in body: {body}")
        return False

# --- User Management ---

def seed_admin():
    """Ensures the default admin exists."""
    admin_email = "fypquranllm@gmail.com"
    if not users_collection.find_one({"email": admin_email}):
        admin_data = {
            "email": admin_email,
            "password_hash": hash_password("787898"),
            "role": "admin",
            "verified": True,
            "created_at": datetime.utcnow()
        }
        users_collection.insert_one(admin_data)
        print("[AUTH] Admin seeded.")

def create_user_pending(email, password, role="user"):
    """Creates a user record with verified=False and returns Success/Fail."""
    
    # 1. Validate Password
    is_valid, msg = validate_password_strength(password)
    if not is_valid:
        return False, msg

    # Check if exists
    existing = users_collection.find_one({"email": email})
    if existing:
        if existing["verified"]:
            return False, "User already exists."
        else:
            # Overwrite unverified user
            users_collection.delete_one({"_id": existing["_id"]})
    
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=10)
    
    user_data = {
        "email": email,
        "password_hash": hash_password(password),
        "role": role,
        "verified": False,
        "otp": otp,
        "otp_expiry": otp_expiry,
        "created_at": datetime.utcnow()
    }
    users_collection.insert_one(user_data)
    
    # Send Email
    send_email(email, "Verify your Account", f"Your Code is: {otp}")
    
    return True, "Verification code sent to email." # OTP not returned

def verify_user_otp(email, otp_input):
    """Verifies OTP and activates account."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "User not found."
    
    if user.get("verified"):
        return True, "Already verified."
        
    if user["otp"] != otp_input:
        return False, "Invalid Code."
        
    if datetime.utcnow() > user["otp_expiry"]:
        return False, "Code Expired."
        
    # Success
    users_collection.update_one(
        {"email": email},
        {"$set": {"verified": True, "otp": None, "otp_expiry": None}}
    )
    return True, "Verification Successful!"

def authenticate_user(email, password):
    """Checks credentials. Returns (Success, Role, Message)."""
    seed_admin() # Ensure admin is always there
    
    user = users_collection.find_one({"email": email})
    if not user:
        return False, None, "User not found."
    
    if not verify_password(password, user["password_hash"]):
        return False, None, "Incorrect password."
        
    if not user.get("verified", False):
        return False, None, "Account not verified."
        
    return True, user["role"], "Success"

def trigger_2fa(email):
    """Generates 2FA code for login."""
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=5)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": otp_expiry}}
    )
    send_email(email, "Security Code", f"Your Login 2FA Code is: {otp}")
    return True # OTP Hidden

def verify_2fa(email, otp_input):
    """Verifies 2FA Login Code."""
    user = users_collection.find_one({"email": email})
    if user["otp"] == otp_input and datetime.utcnow() <= user["otp_expiry"]:
        # Clear OTP
        users_collection.update_one({"email": email}, {"$set": {"otp": None}})
        return True
    return False

def reset_password_request(email):
    """For Forgot Password."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "Email not found."
        
    otp = generate_otp()
    expiry = datetime.utcnow() + timedelta(minutes=10)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": expiry}}
    )
    send_email(email, "Reset Password", f"Your Reset Code is: {otp}")
    return True, "Reset code sent to email." # OTP Hidden

def reset_password_confirm(email, otp, new_password):
    """Resets password using OTP."""
# --- DESCOPE INTEGRATION ---
try:
    from descope import DescopeClient
    from descope.common import DeliveryMethod
    descope_client = DescopeClient(project_id=config.DESCOPE_PROJECT_ID)
except Exception:
    descope_client = None
    print("[AUTH] Descope SDK not found or config error")

def send_magic_link(email, redirect_url=None):
    """Sends a magic link to the user via Descope."""
    if not descope_client:
        return False, "Descope not configured."
    
    # 1. Check Restricted Emails
    if email in config.RESTRICTED_EMAILS:
        return False, "Sorry, this email cannot login using Magic Link."

    # 2. Use Configured Base URL if not provided
    if not redirect_url:
        redirect_url = config.BASE_URL
    
    try:
        descope_client.magiclink.sign_up_or_in(
            method=DeliveryMethod.EMAIL,
            login_id=email,
            uri=redirect_url
        )
        return True, "Magic Link sent! Check your email."
    except Exception as e:
        return False, f"Failed to send Magic Link: {e}"

def verify_magic_link_token(token):
    """Verifies the token from the magic link URL."""
    if not descope_client:
        return None, "Descope not configured."
    
    try:
        jwt_response = descope_client.magiclink.verify(token=token)
        # Extract user info
        user_info = jwt_response.get("user")
        return user_info, "Success"
    except Exception as e:
        return None, f"Token Verification Failed: {e}"

def sync_descope_user(descope_user):
    """
    Syncs Descope user to local MongoDB. 
    If NEW: Generates password, saves it, and emails it to user.
    """
    email = descope_user.get("email") or descope_user.get("loginIds", [])[0]
    
    existing = users_collection.find_one({"email": email})
    if existing:
        return True, existing["role"], "Welcome back!"
    
    # NEW USER -> Generate Backup Password
    backup_password = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$", k=8))
    # Ensure regex compliance just in case (simple retry logic or just force it)
    backup_password = "A1!" + backup_password # Cheating to ensure complexity
    
    user_data = {
        "email": email,
        "password_hash": hash_password(backup_password),
        "role": "user",
        "verified": True, # Verified by Magic Link
        "otp": None,
        "created_at": datetime.utcnow(),
        "auth_provider": "descope"
    }
    users_collection.insert_one(user_data)
    
    # Email the backup password
    send_email(
        email, 
        "Welcome to Quran-ILM - Credentials", 
        f"""
        Welcome! You successfully logged in via Magic Link.
        
        As a backup, we generated a standard password for you:
        Password: {backup_password}
        
        You can use this to log in normally in the future.
        """
    )
    
    return True, "user", "Account Created! Check email for backup password."
