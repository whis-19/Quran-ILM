import hashlib
import os
import random
import string
import secrets
import hashlib
import os
import random
import string
import secrets
import smtplib
import re
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import streamlit as st
from admin_utils import init_connection
import config

# Connect to DB
client, db, fs = init_connection()
users_collection = db["users"]

# --- Security Helpers ---

def hash_password(password):
    """Hashes password using SHA256 with a fixed salt (simple implementation)."""
    # In production, use bcrypt/argon2 and per-user salt.
    salt = "quran_ilm_secure_salt_v1"
    return hashlib.sha256((password + salt).encode()).hexdigest()

def verify_password(plain_password, hashed_password):
    return hash_password(plain_password) == hashed_password

def validate_password_strength(password):
    """
    Enforces password complexity:
    - Min 8 chars
    - At least 1 Uppercase
    - At least 1 Lowercase
    - At least 1 Number
    - At least 1 Special Char
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long."
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter."
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter."
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number."
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character."
    
    return True, "Valid"

def generate_otp():
    """Generates a 6-digit OTP."""
    return ''.join(random.choices(string.digits, k=6))

def send_email(to_email, subject, body):
    """Sends email via SMTP if configured, else mocks it."""
    
    smtp_server = config.SMTP_SERVER
    smtp_port = config.SMTP_PORT
    smtp_user = config.SMTP_EMAIL
    smtp_pass = config.SMTP_PASSWORD

    # --- DISCLAIMER ---
    disclaimer = """
----------------------------
IMPORTANT DISCLAIMER:
This content is generated by an Artificial Intelligence (AI) model and is for educational and informational research purposes ONLY.
It DOES NOT constitute a valid Islamic Fatwa (Religious Ruling) or a substitute for scholarly religious advice.
For specific religious inquiries or rulings, please consult a qualified scholar to avoid religious conflicts or misunderstandings.
The developers and maintainers of this system bear no responsibility for any misuse or misinterpretation of the provided information.
----------------------------
"""
    full_body = body + "\n" + disclaimer
    
    # Check if configured
    if not smtp_user or not smtp_pass or "your_app_password" in smtp_pass:
        print(f"\n[EMAIL MOCK] To: {to_email} | Subject: {subject}\nBody: {full_body}\n")
        return True

    try:
        msg = MIMEText(full_body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = to_email

        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            
        print(f"[EMAIL SUCCESS] Sent to {to_email}")
        return True
    except Exception as e:
        print(f"[EMAIL ERROR] Failed to send: {e}")
        # Fallback to mock so user isn't stuck
        print(f"[EMAIL MOCK FALLBACK] Code for {to_email} is in body: {body}")
        return False

# --- User Management ---

def seed_admin():
    """Ensures the default admin exists."""
    admin_email = "fypquranllm@gmail.com"
    if not users_collection.find_one({"email": admin_email}):
        admin_data = {
            "email": admin_email,
            "password_hash": hash_password("787898"),
            "role": "admin",
            "verified": True,
            "created_at": datetime.utcnow()
        }
        users_collection.insert_one(admin_data)
        print("[AUTH] Admin seeded.")

def create_user_pending(email, password, role="user"):
    """Creates a user record with verified=False and returns Success/Fail."""
    
    # 1. Validate Password
    is_valid, msg = validate_password_strength(password)
    if not is_valid:
        return False, msg

    # Check if exists
    existing = users_collection.find_one({"email": email})
    if existing:
        if existing["verified"]:
            return False, "User already exists."
        else:
            # Overwrite unverified user
            users_collection.delete_one({"_id": existing["_id"]})
    
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=10)
    
    user_data = {
        "email": email,
        "password_hash": hash_password(password),
        "role": role,
        "verified": False,
        "otp": otp,
        "otp_expiry": otp_expiry,
        "created_at": datetime.utcnow()
    }
    users_collection.insert_one(user_data)
    
    # Send Email
    send_email(email, "Verify your Account", f"Your Code is: {otp}")
    
    return True, "Verification code sent to email." # OTP not returned

def verify_user_otp(email, otp_input):
    """Verifies OTP and activates account."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "User not found."
    
    if user.get("verified"):
        return True, "Already verified."
        
    if user["otp"] != otp_input:
        return False, "Invalid Code."
        
    if datetime.utcnow() > user["otp_expiry"]:
        return False, "Code Expired."
        
    # Success
    users_collection.update_one(
        {"email": email},
        {"$set": {"verified": True, "otp": None, "otp_expiry": None}}
    )
    return True, "Verification Successful!"

def authenticate_user(email, password):
    """Checks credentials. Returns (Success, Role, Message)."""
    seed_admin() # Ensure admin is always there
    
    user = users_collection.find_one({"email": email})
    if not user:
        return False, None, "User not found."
    
    if not verify_password(password, user["password_hash"]):
        return False, None, "Incorrect password."
        
    if not user.get("verified", False):
        return False, None, "Account not verified."
        
    return True, user["role"], "Success"

def trigger_2fa(email):
    """Generates 2FA code for login."""
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=5)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": otp_expiry}}
    )
    send_email(email, "Security Code", f"Your Login 2FA Code is: {otp}")
    return True # OTP Hidden

def verify_2fa(email, otp_input):
    """Verifies 2FA Login Code."""
    user = users_collection.find_one({"email": email})
    if user["otp"] == otp_input and datetime.utcnow() <= user["otp_expiry"]:
        # Clear OTP
        users_collection.update_one({"email": email}, {"$set": {"otp": None}})
        return True
    return False

def reset_password_request(email):
    """For Forgot Password."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "Email not found."
        
    otp = generate_otp()
    expiry = datetime.utcnow() + timedelta(minutes=10)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": expiry}}
    )
    send_email(email, "Reset Password", f"Your Reset Code is: {otp}")
    return True, "Reset code sent to email." # OTP Hidden

def reset_password_confirm(email, otp, new_password):
    """Resets password using OTP."""
    if verify_2fa(email, otp): # Reuse 2FA check logic
        users_collection.update_one(
            {"email": email},
            {"$set": {"password_hash": hash_password(new_password)}}
        )
        return True, "Password Reset Successfully."
    return False, "Invalid or Expired Code."
