import hashlib
import os
import random
import string
import secrets
import hashlib
import os
import random
import string
import secrets
import smtplib
import re
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import streamlit as st
from .admin_utils import init_connection
from . import config

# Connect to DB
client, db, fs = init_connection()
users_collection = db["users"]

# --- Security Helpers ---

def hash_password(password):
    """Hashes password using SHA256 with a fixed salt (simple implementation)."""
    # In production, use bcrypt/argon2 and per-user salt.
    salt = "quran_ilm_secure_salt_v1"
    return hashlib.sha256((password + salt).encode()).hexdigest()

def verify_password(plain_password, hashed_password):
    return hash_password(plain_password) == hashed_password

def validate_password_strength(password):
    """
    Enforces password complexity:
    - Min 8 chars
    - At least 1 Uppercase
    - At least 1 Lowercase
    - At least 1 Number
    - At least 1 Special Char
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long."
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter."
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter."
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number."
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character."
    
    return True, "Valid"

def generate_otp():
    """Generates a 6-digit OTP."""
    return ''.join(random.choices(string.digits, k=6))

def send_email(to_email, subject, body_html):
    """Sends email via SMTP (HTML format) if configured, else mocks it."""
    
    smtp_server = config.SMTP_SERVER
    smtp_port = config.SMTP_PORT
    smtp_user = config.SMTP_EMAIL
    smtp_pass = config.SMTP_PASSWORD

    # --- DISCLAIMER (HTML) ---
    disclaimer_html = """
    <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 15px; font-size: 12px; color: #888; font-family: sans-serif;">
        <p><strong>IMPORTANT DISCLAIMER:</strong></p>
        <p>This content is generated by an Artificial Intelligence (AI) model and is for educational and informational research purposes ONLY.</p>
        <p>It DOES NOT constitute a valid Islamic Fatwa (Religious Ruling) or a substitute for scholarly religious advice.</p>
        <p>For specific religious inquiries or rulings, please consult a qualified scholar to avoid religious conflicts or misunderstandings.</p>
        <p>The developers and maintainers of this system bear no responsibility for any misuse or misinterpretation of the provided information.</p>
    </div>
    """
    
    full_body = f"""
    <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: auto;">
        {body_html}
        {disclaimer_html}
    </div>
    """
    
    # Check if configured
    if not smtp_user or not smtp_pass or "your_app_password" in smtp_pass:
        # Strip HTML for mock print readability (optional, but keeps logs clean)
        clean_text = re.sub('<[^<]+?>', '', body_html) 
        print(f"\n[EMAIL MOCK] To: {to_email} | Subject: {subject}\nBody (HTML Preview): {clean_text}\n")
        return True

    try:
        msg = MIMEText(full_body, 'html')
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = to_email

        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            
        print(f"[EMAIL SUCCESS] Sent to {to_email}")
        return True
    except Exception as e:
        print(f"[EMAIL ERROR] Failed to send: {e}")
        # Fallback to mock so user isn't stuck
        print(f"[EMAIL MOCK FALLBACK] HTML Body length: {len(full_body)}")
        return False

# --- User Management ---

def seed_admin():
    """Ensures the default admin exists."""
    admin_email = "fypquranllm@gmail.com"
    if not users_collection.find_one({"email": admin_email}):
        admin_data = {
            "email": admin_email,
            "password_hash": hash_password("787898"),
            "role": "admin",
            "verified": True,
            "created_at": datetime.utcnow()
        }
        users_collection.insert_one(admin_data)
        print("[AUTH] Admin seeded.")

def create_user_pending(email, password, role="user"):
    """Creates a user record with verified=False and returns Success/Fail."""
    
    # 1. Validate Password
    is_valid, msg = validate_password_strength(password)
    if not is_valid:
        return False, msg

    # Check if exists
    existing = users_collection.find_one({"email": email})
    if existing:
        if existing["verified"]:
            return False, "User already exists."
        else:
            # Overwrite unverified user
            users_collection.delete_one({"_id": existing["_id"]})
    
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=10)
    
    user_data = {
        "email": email,
        "password_hash": hash_password(password),
        "role": role,
        "verified": False,
        "otp": otp,
        "otp_expiry": otp_expiry,
        "created_at": datetime.utcnow()
    }
    users_collection.insert_one(user_data)
    
    # Send Email
    html_body = f"""
    <h2>Verify your Account</h2>
    <p>Welcome to Quran-ILM! Please use the following code to verify your account:</p>
    <h1 style="color: #4CAF50; letter-spacing: 5px;">{otp}</h1>
    <p>This code expires in 10 minutes.</p>
    """
    send_email(email, "Verify your Account", html_body)
    
    return True, "Verification code sent to email." # OTP not returned

def verify_user_otp(email, otp_input):
    """Verifies OTP and activates account."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "User not found."
    
    if user.get("verified"):
        return True, "Already verified."
        
    if user["otp"] != otp_input:
        return False, "Invalid Code."
        
    if datetime.utcnow() > user["otp_expiry"]:
        return False, "Code Expired."
        
    # Success
    users_collection.update_one(
        {"email": email},
        {"$set": {"verified": True, "otp": None, "otp_expiry": None}}
    )
    return True, "Verification Successful!"

def authenticate_user(email, password):
    """Checks credentials. Returns (Success, Role, Message)."""
    seed_admin() # Ensure admin is always there
    
    user = users_collection.find_one({"email": email})
    if not user:
        return False, None, "User not found."
    
    if not verify_password(password, user["password_hash"]):
        return False, None, "Incorrect password."
        
    if not user.get("verified", False):
        return False, None, "Account not verified."
        
    return True, user["role"], "Success"

def trigger_2fa(email):
    """Generates 2FA code for login."""
    otp = generate_otp()
    otp_expiry = datetime.utcnow() + timedelta(minutes=5)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": otp_expiry}}
    )
    html_body = f"""
    <h2>Two-Factor Authentication</h2>
    <p>Someone attempted to log in to your admin account.</p>
    <p>Your Security Code is:</p>
    <h1 style="color: #d9534f; letter-spacing: 5px;">{otp}</h1>
    """
    send_email(email, "Security Code", html_body)
    return True # OTP Hidden

def verify_2fa(email, otp_input):
    """Verifies 2FA Login Code."""
    user = users_collection.find_one({"email": email})
    if user["otp"] == otp_input and datetime.utcnow() <= user["otp_expiry"]:
        # Clear OTP
        users_collection.update_one({"email": email}, {"$set": {"otp": None}})
        return True
    return False

def reset_password_request(email):
    """For Forgot Password."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "Email not found."
        
    otp = generate_otp()
    expiry = datetime.utcnow() + timedelta(minutes=10)
    
    users_collection.update_one(
        {"email": email},
        {"$set": {"otp": otp, "otp_expiry": expiry}}
    )
    html_body = f"""
    <h2>Password Reset Request</h2>
    <p>You requested a password reset. Use the code below:</p>
    <h1 style="color: #0275d8; letter-spacing: 5px;">{otp}</h1>
    <p>If you did not request this, please ignore this email.</p>
    """
    send_email(email, "Reset Password", html_body)
    return True, "Reset code sent to email." # OTP Hidden

def reset_password_confirm(email, otp, new_password):
    """Resets password using OTP."""
    user = users_collection.find_one({"email": email})
    if not user:
        return False, "User not found."
        
    if user.get("otp") != otp:
        return False, "Invalid Code."
        
    if datetime.utcnow() > user.get("otp_expiry", datetime.min):
        return False, "Code Expired."
        
    # Update Password and Clear OTP
    new_hash = hash_password(new_password)
    users_collection.update_one(
        {"email": email},
        {"$set": {
            "password_hash": new_hash, 
            "otp": None, 
            "otp_expiry": None
        }}
    )
    return True, "Password successfully reset."

# --- DESCOPE INTEGRATION ---
try:
    from descope import DescopeClient
    from descope.common import DeliveryMethod
    descope_client = DescopeClient(project_id=config.DESCOPE_PROJECT_ID)
except Exception:
    descope_client = None
    print("[AUTH] Descope SDK not found or config error")

def send_magic_link(email, redirect_url=None, intent="login"):
    """
    Sends a magic link to the user via Descope.
    intent: 'login' (must exist) or 'signup' (must NOT exist)
    """
    if not descope_client:
        return False, "Descope not configured."
    
    # 1. Check Restricted Emails
    if email in config.RESTRICTED_EMAILS:
        return False, "Sorry, this email cannot login using Magic Link."

    # 2. Strict Intent Checks
    user_exists = users_collection.find_one({"email": email})
    
    if intent == "login":
        if not user_exists:
            return False, "User not found. Please Sign Up first."
            
    elif intent == "signup":
        if user_exists:
            return False, "Account already exists. Please Log In."

    # 3. Use Configured Base URL if not provided
    if not redirect_url:
        redirect_url = config.BASE_URL
    
    try:
        descope_client.magiclink.sign_up_or_in(
            method=DeliveryMethod.EMAIL,
            login_id=email,
            uri=redirect_url
        )
        return True, "Magic Link sent! Check your email."
    except Exception as e:
        return False, f"Failed to send Magic Link: {e}"

def verify_magic_link_token(token):
    """Verifies the token from the magic link URL."""
    if not descope_client:
        return None, "Descope not configured."
    
    try:
        jwt_response = descope_client.magiclink.verify(token=token)
        # Extract user info
        user_info = jwt_response.get("user")
        return user_info, "Success"
    except Exception as e:
        return None, f"Token Verification Failed: {e}"

def sync_descope_user(descope_user):
    """
    Syncs Descope user to local MongoDB. 
    If NEW: Generates password, saves it, and emails it to user.
    """
    email = descope_user.get("email") or descope_user.get("loginIds", [])[0]
    
    existing = users_collection.find_one({"email": email})
    if existing:
        return True, existing["role"], "Welcome back!"
    
    # NEW USER -> Generate Backup Password
    backup_password = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$", k=8))
    # Ensure regex compliance just in case (simple retry logic or just force it)
    backup_password = "A1!" + backup_password # Cheating to ensure complexity
    
    user_data = {
        "email": email,
        "password_hash": hash_password(backup_password),
        "role": "user",
        "verified": True, # Verified by Magic Link
        "otp": None,
        "created_at": datetime.utcnow(),
        "auth_provider": "descope"
    }
    users_collection.insert_one(user_data)
    
    # Email the backup password
    html_body = f"""
    <h2>Welcome to Quran-ILM! ‚ò™Ô∏è</h2>
    <p>You have successfully logged in via <b>Magic Link</b>.</p>
    <p>For your convenience, we have generated a secure backup password for you. You can use this to log in normally in the future if you prefer not to use the magic link.</p>
    <br>
    <div style="background-color: #f9f9f9; padding: 15px; border-left: 4px solid #4CAF50;">
        <ul style="list-style-type: none; padding: 0;">
            <li><b>üìß Email:</b> {email}</li>
            <li><b>üîë Backup Password:</b> {backup_password}</li>
        </ul>
    </div>
    <br>
    <p>We recommend changing this password after you check in.</p>
    """
    send_email(
        email, 
        "Welcome to Quran-ILM - Credentials", 
        html_body
    )
    
    return True, "user", "Account Created! Check email for backup password."
